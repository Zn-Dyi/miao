第二个参数: 函数, 第 3 次执行第二个参数: 函数, 第 ... 次执行 现象：useEffect 会在第一次渲染以及每次更新渲染后都执行。 解决方法： 使用useCallback，useCallback返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。 const [count, setCount] = useState(1); const consoleFunction = useCallback(() => { console.log('consoleFunction'); }, []); useEffect(() => { setCount(count + 1); console.log(`第二个参数: 函数, 第 ${count} 次执行`); }, [consoleFunction]); // 打印log，执行一次第二个参数: 函数, 第 1 次执行 // 3、对象作为依赖： const [count, setCount] = useState(1); const obj = {name: 'zhangsan'}; useEffect(() => { setTimeout(() => { setCount(count + 1); }, 1000); console.log(`第二个参数: 对象, 第 ${count} 次执行`); }, [obj]); // 打印log，无限循环第二个参数: 对象, 第 1 次执行第二个参数: 对象, 第 2 次执行第二个参数: 对象, 第 3 次执行第二个参数: 对象, 第 ... 次执行 现象：useEffect 会在第一次渲染以及每次更新渲染后都执行。 解决方法： 使用useMemo，useMemo该回调函数仅在某个依赖项改变时才会更新。此处使用[]依赖，组件重新渲染后对象不再重新定义。 const [count, setCount] = useState(1) const obj = useMemo(() => ({ name: 'zhang' }), []) useEffect (() => { setCount(count + 1) console.log(`第二个参数: 对象, 第 ${count} 次执行`); }, [obj]) // 打印log 第二个参数: 对象, 第 1 次执行
